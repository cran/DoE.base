\name{fac.design}
\alias{fac.design}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{ Function for full factorial designs }
\description{
  Function for creating full factorial designs with arbitrary numbers of levels,
  and potentially with blocking
}
\usage{
fac.design(nlevels=NULL, nfactors=NULL, factor.names = NULL,
        replications=1, repeat.only = FALSE, randomize=TRUE, seed=NULL,
        blocks=1, block.gen=NULL, block.name="Blocks", bbreps=replications,
        wbreps=1, block.old.behavior=FALSE)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{nlevels}{ number(s) of levels, vector with \code{nfactors} entries or single number;
                  can be omitted, if obvious from \code{factor.names} }
  \item{nfactors}{ number of factors, can be omitted if obvious from entries \code{nlevels} or \code{factor.names} }
  \item{factor.names}{ if \code{nlevels} is given, \code{factor.names} can be a character vector of factor names.
        In this case, default factor levels are the numbers from 1 to the number of levels for each factor.\cr
        Otherwise it must be a list of vectors with factor levels.
        If the list is named, list names represent factor names, otherwise default factor names are used.
        Default factor names are the first elements of the character vector \code{\link{Letters}},
        or the factors position numbers preceded by capital F in case of more than 50 factors.
        If both \code{nlevels} and factor.names are
        given, they must be compatible.}
  \item{replications}{ positive integer number. Default 1 (i.e. each row just once).
       If larger, each design run is executed replication times.
       If \code{repeat.only}, repeated measurements
       are carried out directly in sequence, i.e. no true replication takes place,
       and all the repeat runs are conducted together. It is likely that the error
       variation generated by such a procedure will be too small, so that average values
       should be analyzed for an unreplicated design.

       Otherwise (default), the full experiment is first carried out once, then
       for the second replication and so forth. In case of randomization,
       each such blocks is randomized separately. In this case, replication variance is
       more likely suitable for usage as error variance
       (unless e.g. the same parts are used for replication runs although build
       variation is important).}
  \item{repeat.only}{ logical, relevant only if replications > 1. If \code{TRUE},
        replications of each run are grouped together
       (repeated measurement rather than true replication). The default is
       \code{repeat.only=FALSE}, i.e. the complete experiment
       is conducted in \code{replications} blocks, and each run occurs in each block.  }
  \item{randomize}{ logical. If \code{TRUE}, the design is randomized. This is the default.
       In case of replications, the nature of randomization depends on the setting of
       option \code{repeat.only}.}
  \item{seed}{ integer seed for the random number generator \cr
        In R version 3.6.0 and later, the default behavior of function \code{\link{sample}}
        has changed. If you work in a new (i.e., >= 3.6.-0) R version and want to reproduce
        a randomized design from an earlier R version (before 3.6.0),
        you have to change the RNGkind setting by\cr
        \code{RNGkind(sample.kind="Rounding")}\cr
        before running function \code{fac.design}.\cr
        It is recommended to change the setting back to the new recommended way afterwards:\cr
        \code{RNGkind(sample.kind="default")}\cr
        For an example, see the documentation of the example data set \code{\link{VSGFS}}.
        }
  \item{blocks}{ is the number of blocks into which the experiment is to be subdivided; \cr
       it must be a prime or a product of prime numbers which occur as common divisors
       of the numbers of levels of several factors (cf. Details section).\cr

       If the experiment is randomized, randomization happens within blocks. \cr
       }
  \item{block.gen}{ provides block generating information.\cr
       Only specify \code{block.gen}, if \code{blocks}>1. \cr
       If \code{blocks} is a prime or a power of 2 (up to 2^8) or 3 (up to 3^5)
       or a product of powers of 2, 3, and an individual other prime,
       \code{block.gen} is not needed (but can be optionally specified).\cr
       If given, \code{block.gen} can be \cr
       a numeric vector of integer numbers that will be treated as a one-row matrix \cr
       OR a numeric matrix with integer elements.

       There must be a row for each prime number into which \code{blocks} factorizes,
       and a column for each (pseudo)factor into which the experimental
       design factors can be partitioned (cf. Details and Examples sections and
       function \code{\link[conf.design]{factorize}}).

       Rows for a p-level contributor to the block factor (p a prime) consist of
       entries 0 to p-1 only.
       }
  \item{block.name}{ name of the block factor, default \dQuote{Blocks}}
  \item{bbreps}{ between block replications; these are always taken as genuine replications,
       not repeat runs; default: equal to \code{replications};
       CAUTION: you should not modify \code{bbreps} if you do not work with blocks,
       because the program code uses it instead of \code{replications} in some places }
  \item{wbreps}{ within block replications; whether or not these are taken as genuine replications
       depends on the setting of \code{repeat.only}}
  \item{block.old.behavior}{logical that can be used to activate the old (prior
       to version 0.27) behavior of
       blocking full factorial designs; the new behavior is the default, as it
       often creates designs with less severe confounding }
  }
\details{
   \code{fac.design} creates full factorial designs, i.e. the number of runs is the
   product of all numbers of levels.\cr\cr
   It is possible to subdivide the design into blocks (one hierarchy level only)
   by specifying an appropriate number of blocks. The method used is a generalization of
   the one implemented in function \code{\link[conf.design]{conf.design}} for
   symmetric factorials (i.e. factorials with all factors at the same prime number
   of levels) and related to the method described in Collings (1984, 1989);
   function \code{\link[conf.design]{conf.set}} from
   package \pkg{conf.design} is used for checking the confounding
   consequences of blocking.

   Note that the number of blocks must
   be compatible with the factor levels; it must factor into primes that occur with
   high enough frequency among the pseudo-factors of the design.
   This statement is now explained by an example: Consider a design with five factors at
   2, 2, 3, 3, 6 levels. The 6-level factor can be thought of as consisting of
   two pseudo-factors, a 2-level and a 3-level pseudo-factor, according to the
   factorization of the number 6 into the two primes 2 and 3. It is possible \cr
   to obtain two blocks by confounding the two-factor interaction of the
   two 2-level factors and the 2-level pseudo-factor of the 6-level factor, \cr
   or to obtain three blocks by confounding the blocking factor with the
   three-factor interaction of the two three-level factors and the three-level
   pseudo-factor of the 6-level factor, \cr
   or to get six blocks, by doing both simultaneously. \cr
   It is also possible to obtain 4 or 9 or even 36 blocks, if one is happy to
   confound two-factor interactions with blocks. The 36 blocks are the product
   of the 4 blocks from the 2-level portion with the nine blocks from the 3-level
   portion. For each portion separately, there is a lookup-table for blocking
   possibilities (\code{\link{block.catlg}}), for up to 128 blocks in 256 runs,
   or up to 81 blocks in 243 runs.

   5 blocks cannot be done for the above example design. Even if there were one additional
   factor at 5 levels, it would still not be possible to do a number of blocks
   with divisor 5, because this would confound the main effect of a factor with
   blocks and would thus generate an error.

   For any primes apart from 2 or 3, only one at a time can be handled automatically.
   For example, if a design has three 5-level factors, it can be automatically subdivided
   into 5 blocks by the option \code{blocks=5}.
   It is also possible to run the design in 25 blocks; however, as 25=5*5, this cannot be done
   automatically but has to be requested by specifying the \code{block.gen} option
   in addition to the \code{blocks} option
   (in this case, \code{block.gen=rbind(c(1,0,1),c(1,1,0))} would do the job).

}
\value{
    \code{fac.design} returns a data frame of S3 class \code{\link{design}}
    with attributes attached.

   The experimental factors are all stored as R factors. \cr
   For factors with 2 levels, \code{\link{contr.FrF2}} contrasts (-1 / +1) are used. \cr
   For factors with more than 2 numerical levels, polynomial contrasts are used
   (i.e. analyses will per default use orthogonal polynomials). \cr
   For factors with more than 2 categorical levels, the default contrasts are used.

   For changing the contrasts, use function \code{\link{change.contr}}.

   The \code{design.info} attribute of the data frame has the following elements:
  \describe{
    \item{type}{ character string \dQuote{full factorial} or
         \dQuote{full factorial.blocked}}
    \item{nruns}{ number of runs (replications are not counted) }
    \item{nfactors}{ number of factors}
    \item{nlevels}{ vector with number of levels for each factor }
    \item{factor.names }{ list named with (treatment) factor names and containing as
         entries vectors with coded factor levels }
    \item{nblocks}{for designs of type \code{full factorial.blocked} only; \cr
         number of blocks}
    \item{block.gen}{for designs of type \code{full factorial.blocked} only; \cr
         matrix the rows of which are the coefficients of the linear combinations
         that create block columns from of pseudo factors}
    \item{blocksize}{for designs of type \code{full factorial.blocked} only; \cr
         size of each block (without consideration of \code{wbreps})}
    \item{replication }{ option setting in call to \code{FrF2} }
    \item{repeat.only }{ option setting in call to \code{FrF2} }
    \item{bbreps}{for designs of type \code{FrF2.blocked} only;
         number of between block replications}
    \item{wbreps}{for designs of type \code{FrF2.blocked} only;
         number of within block replications;\cr
         \code{repeat.only} indicates whether these are replications or repetitions only}
    \item{randomize }{ option setting in call to \code{FrF2} }
    \item{seed }{ option setting in call to \code{FrF2} }
    \item{creator }{ call to function FrF2
         (or stored menu settings, if the function has been called via the R commander plugin
         \pkg{RcmdrPlugin.DoE}) }
         }
}
\section{Warning}{
   Since R version 3.6.0, the behavior of function \code{\link{sample}} has changed
   (correction of a biased previous behavior that should not be relevant for the randomization of designs).
   For reproducing a randomized design that was produced with an earlier R version,
   please follow the steps described with the argument \code{seed}.
}

\references{
  Collings, B.J. (1984). Generating the intrablock and interblock subgroups for
     confounding in general factorial experiments. \emph{Annals of Statistics} \bold{12},
     1500--1509.

  Collings, B.J. (1989). Quick confounding. \emph{Technometrics} \bold{31},
     107--110.
  }
\author{ Ulrike Groemping }
\note{ This package is still under development. Suggestions and bug reports are welcome.}
\seealso{ See also \code{\link[FrF2]{FrF2}}, \code{\link{oa.design}}, \code{\link[FrF2]{pb}}, \code{\link[conf.design]{conf.set}},
    \code{\link{block.catlg}}}
\examples{
  ## only specify level combination
  fac.design(nlevels=c(4,3,3,2))
  ## design requested via factor.names
  fac.design(factor.names=list(one=c("a","b","c"), two=c(125,275),
     three=c("old","new"), four=c(-1,1), five=c("min","medium","max")))
  ## design requested via character factor.names and nlevels
  ##    (with a little German lesson for one two three)
  fac.design(factor.names=c("eins","zwei","drei"),nlevels=c(2,3,2))

  ### blocking designs
  fac.design(nlevels=c(2,2,3,3,6), blocks=6, seed=12345)
  ## the same design, now unnecessarily constructed via option block.gen
  ## preparation: look at the numbers of levels of pseudo factors
  ## (in this order)
  unlist(factorize(c(2,2,3,3,6)))
  ## or, for more annotation, factorize the unblocked design
  factorize(fac.design(nlevels=c(2,2,3,3,6)))
  ## positions 1 2 5 are 2-level pseudo factors
  ## positions 3 4 6 are 4-level pseudo factors
  ## blocking with highest possible interactions
  G <- rbind(two=c(1,1,0,0,1,0),three=c(0,0,1,1,0,1))
  plan.6blocks <- fac.design(nlevels=c(2,2,3,3,6), blocks=6, block.gen=G, seed=12345)
  plan.6blocks

  ## two blocks, default design, but unnecessarily constructed via block.gen
  fac.design(nlevels=c(2,2,3,3,6), blocks=2, block.gen=c(1,1,0,0,1,0), seed=12345)

  ## three blocks, default design, but unnecessarily constructed via block.gen
  fac.design(nlevels=c(2,2,3,3,6), blocks=3, block.gen=c(0,0,1,1,0,1), seed=12345)

  ## nine blocks
  ## confounding two-factor interactions cannot be avoided
  ## there are warnings to that effect
  G <- rbind(CD=c(0,0,1,1,0,0),CE2=c(0,0,1,0,0,1))
  plan.9blocks <- fac.design(nlevels=c(2,2,3,3,6), blocks=9, block.gen=G, seed=12345)

  ## further automatic designs, not run for shortening run time
  \dontrun{
  fac.design(nlevels=c(2,2,3,3,6), blocks=4, seed=12345)
  fac.design(nlevels=c(2,2,3,3,6), blocks=9, seed=12345)
  fac.design(nlevels=c(2,2,3,3,6), blocks=36, seed=12345)
  fac.design(nlevels=c(3,5,6,10), blocks=15, seed=12345)
  }

  ## independently check aliasing
  ## model with block main effects and all two-factor interactions
  ## 6 factors: not aliased
  summary(plan.6blocks)
  alias(lm(1:nrow(plan.6blocks)~Blocks+(A+B+C+D+E)^2,plan.6blocks))
  ## 9 factors: aliased
  summary(plan.9blocks)
  alias(lm(1:nrow(plan.9blocks)~Blocks+(A+B+C+D+E)^2,plan.9blocks))
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ array }
\keyword{ design }% __ONLY ONE__ keyword per line
